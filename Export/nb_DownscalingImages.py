
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/DownscalingImages.ipynb
import numpy as np
import cv2

from Export.nb_Convolutions1D import fixedSizeQueue, derivative, gaussianConv
from Export.nb_UpScalingImages import createPixelTransform
from Export.nb_PixelManipulation import getChannels, iterateImage
from queue import SimpleQueue

def getTargetConvSize(current_size : tuple, target_size : tuple):
    target_height = (current_size[0] - 1) // target_size[0] + 1
    if target_height % 2 == 0 : target_height += 1
    target_width = (current_size[1] - 1) // target_size[1] + 1
    if target_width % 2 == 0 : target_width += 1
    return (target_height, target_width)

def resetAllConvolutionQueues(conv_queues, nr_channels):
    for k in range(nr_channels):
        conv_queues[k].reset()

def iterateRemainingIndex(k, queue_ind, nr_channels):
    k += 1
    if k == nr_channels:
        k = 0
        queue_ind += 1
    return k, queue_ind

def strideConvolveRemaining(queue_ind : int, nr_channels : int,
        update_queues : list, conv_queues : list, valid_idx : np.array):
    k = 0
    last_indices = len(valid_idx)
    while queue_ind < last_indices:
        conv_queues[k].update()
        prev_px = update_queues[k].get()
        if valid_idx[queue_ind] : prev_px[...] = conv_queues[k].convolve()
        k, queue_ind = iterateRemainingIndex(k, queue_ind, nr_channels)
    resetAllConvolutionQueues(conv_queues, nr_channels)

def getValidTransformCordinates(arr_len : int, update_lag : int, use_height : bool, coordinateTransform):
    valid_idx = np.ndarray(arr_len + update_lag, dtype = np.bool)
    valid_idx.fill(False)
    prev_target = -1
    for pxInd in range(arr_len):
        if use_height:
            current_target, _ = np.floor(coordinateTransform(pxInd, 0))
        else:
            _, current_target = np.floor(coordinateTransform(0, pxInd))
        if current_target != prev_target:
            valid_idx[pxInd + update_lag] = True
            prev_target = current_target
    return valid_idx

def verticalStrideConvolution(output_img : np.array, gauss_conv : np.array, coordinateTransform):
    i, j, k = 0, 0, 0
    _, height, width, channels, _ = getChannels(output_img)
    update_lag = len(gauss_conv) // 2
    conv_queues = [fixedSizeQueue(gauss_conv, 255, dtype = np.float32) for _ in range(channels)]
    update_queues = [SimpleQueue()]
    valid_height_idx = getValidTransformCordinates(height, update_lag, True, coordinateTransform)
    for px in np.nditer(output_img, order = 'F', op_flags = ['readwrite']):
        conv_queues[k].update(px)
        update_queues[0].put(px)
        if i >= update_lag:
            prev_px = update_queues[0].get()
            if valid_height_idx[i] : prev_px[...] = conv_queues[k].convolve()
        i, j, k = iterateImageFortran(i, j, k, height, width)
        if i == 0 : strideConvolveRemaining(height, 1, update_queues, conv_queues, valid_height_idx)
    return output_img

def horizontalStrideConvolution(output_img : np.array, gauss_conv : np.array, coordinateTransform):
    i, j, k = 0, 0, 0
    _, _, width, channels, _ = getChannels(output_img)
    update_lag = len(gauss_conv) // 2
    conv_queues = [fixedSizeQueue(gauss_conv, 255, dtype = np.float32) for _ in range(channels)]
    update_queues = [SimpleQueue() for _ in range(channels)]
    valid_width_idx = getValidTransformCordinates(width, update_lag, False, coordinateTransform)
    for px in np.nditer(output_img, order = 'C', op_flags = ['readwrite']):
        conv_queues[k].update(px)
        update_queues[k].put(px)
        if j >= update_lag:
            prev_px = update_queues[k].get()
            if valid_width_idx[j] : prev_px[...] = conv_queues[k].convolve()
        i, j, k = iterateImage(i, j, k, channels, width)
        if j == 0 and k == 0:
            strideConvolveRemaining(width, channels, update_queues, conv_queues, valid_width_idx)
    return output_img

def outputStrideConvRemaining(output_img : np.array, dim_length : int, valid_idx : np.array,
        conv_queues : list, nr_channels : int, current_ind : int, update_lag : int,
        update_height : bool, coordinateTransform):
    k = 0
    nr_last_indices = len(valid_idx)
    queue_ind = dim_length
    while queue_ind < nr_last_indices:
        conv_queues[k].update()
        if valid_idx[queue_ind]:
            if update_height:
                out_i, out_j = np.uint32(np.floor(coordinateTransform(current_ind, queue_ind - update_lag)))
            else:
                out_i, out_j = np.uint32(np.floor(coordinateTransform(queue_ind - update_lag, current_ind)))
            output_img[out_i, out_j] = conv_queues[k].convolve()
        k, queue_ind = iterateRemainingIndex(k, queue_ind, nr_channels)
    resetAllConvolutionQueues(conv_queues, nr_channels)

def horizontalOutputConvolution(input_img : np.array, output_img : np.array,
        gauss_conv : np.array, coordinateTransform):
    i, j, k = 0, 0, 0
    update_lag = len(gauss_conv) // 2
    _, height, width, channels, _ = getChannels(input_img)
    conv_queues = [fixedSizeQueue(gauss_conv, 255, dtype = np.float32) for _ in range(channels)]
    valid_width_idx = getValidTransformCordinates(width, update_lag, False, coordinateTransform)
    valid_height_idx = getValidTransformCordinates(height, 0, True, coordinateTransform)
    for px in np.nditer(input_img, order = 'C', op_flags = ['readonly']):
        conv_queues[k].update(px)
        if j >= update_lag:
            if valid_height_idx[i] and valid_width_idx[j]:
                out_i, out_j = np.uint32(np.floor(coordinateTransform(i, j-update_lag)))
                output_img[out_i, out_j, k] = conv_queues[k].convolve()
        if j == width - 1 and k == 0 and valid_height_idx[i]:
            outputStrideConvRemaining(output_img, width, valid_width_idx,
                conv_queues, channels, i, update_lag, True, coordinateTransform)
        i, j, k = iterateImage(i, j, k, channels, width)
    return output_img

def verticalOutputConvolution(input_img : np.array, output_img : np.array,
        gauss_conv : np.array, coordinateTransform):
    i, j, k = 0, 0, 0
    update_lag = len(gauss_conv) // 2
    _, height, width, channels, _ = getChannels(input_img)
    valid_width_idx = getValidTransformCordinates(width, 0, False, coordinateTransform)
    valid_height_idx = getValidTransformCordinates(height, update_lag, True, coordinateTransform)
    conv_queues = [fixedSizeQueue(gauss_conv, 255, dtype = np.float32) for _ in range(channels)]
    for px in np.nditer(input_img, order = 'F', op_flags = ['readonly']):
        conv_queues[k].update(px)
        if i >= update_lag:
            if valid_height_idx[i] and valid_width_idx[j]:
                out_i, out_j = np.uint32(np.floor(coordinateTransform(i-update_lag, j)))
                output_img[out_i, out_j, k] = conv_queues[k].convolve()
        if i == height - 1 and valid_width_idx[j]:
            outputStrideConvRemaining(output_img, height, valid_height_idx,
                conv_queues, 1, j, update_lag, False, coordinateTransform)
        i, j, k = iterateImageFortran(i, j, k, height, width)
    return output_img

def downSizeImage(img : np.array, target_size : tuple):
    input_img = img.copy()
    current_size = input_img.shape[:2]
    channels = input_img.shape[2]
    target_conv = getTargetConvSize(frog_current_size, frog_target_size)
    sizeTransform = createPixelTransform(target_size + np.array([1,1]), current_size - np.array([1,1]))
    gauss_conv1, gauss_conv2 = gaussianConv(*target_conv) # vertical conv, horizontal conv
    output_shape = list(target_size) + [channels]
    output_img = np.ndarray(output_shape, dtype = np.uint8)
    if target_conv[0] > target_conv[1]:
        input_img = horizontalStrideConvolution(input_img, gauss_conv2, sizeTransform)
        output_img = verticalOutputConvolution(input_img, output_img, gauss_conv1, sizeTransform)
    else:
        input_img = verticalStrideConvolution(input_img, gauss_conv1, sizeTransform)
        output_img = horizontalOutputConvolution(input_img, output_img, gauss_conv2, sizeTransform)
    return output_img