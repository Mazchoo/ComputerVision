
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/Convolutions1D.ipynb
import numpy as np
import cv2
from queue import SimpleQueue
from functools import lru_cache

from Export.nb_PixelManipulation import *

@lru_cache()
def choice(m : int, n : int):
    if m == 1: return 1
    if n == 0: return 1
    if n == m: return 1
    if n == 1: return m
    return choice(m - 1, n) + choice(m - 1, n - 1)

def gaussian(conv_len : int):
    output = np.ndarray(conv_len, dtype = np.float32)
    output[0] = 1
    m = conv_len
    n = 0
    for i in range(1, (conv_len + 1) // 2):
        n += 1; m -= 1
        output[i] = output[i - 1] * m / n
    for i in range(conv_len // 2):
        output[-i - 1] = output[i]
    return output

def averageBlur(conv_len : int):
    output = np.ndarray(conv_len, dtype = np.float32)
    output.fill(1)
    return output

def derivative(conv_len : int):
    output = np.ndarray(conv_len, dtype = np.float32)
    i = 0
    mid_point = conv_len // 2
    neg = True
    for x in np.nditer(output, op_flags = ['writeonly']):
        if i == mid_point: x[...] = 0.; neg = False; i += 1; continue
        x[...] = -1. if neg else 1.
        i += 1
    return output


def gaussianConv(n1 : int, n2 : int):
    if n1 % 2 != 1: print('Convolution size must be odd!', n1); return
    if n2 % 2 != 1: print('Convolution size must be odd!', n2); return
    conv1 = gaussian(n1); conv1 /= np.sum(conv1)
    conv2 = gaussian(n2); conv2 /= np.sum(conv2)
    return conv1, conv2

def derivativeConv(n1 : int, n2 : int):
    if n1 % 2 != 1: print('Convolution size must be odd!', n1); return
    if n2 % 2 != 1: print('Convolution size must be odd!', n2); return
    conv1 = gaussian(n1)
    conv2 = derivative(n2)
    return conv1, conv2

def averageConv(n1 : int, n2 : int):
    if n1 % 2 != 1: print('Convolution size must be odd!', n1); return
    if n2 % 2 != 1: print('Convolution size must be odd!', n2); return
    conv1 = averageBlur(n1) / n1
    conv2 = averageBlur(n2) / n2
    return conv1, conv2

class fixedSizeQueue:
    def __init__(self, n_elements : int, padding_value : int, conv_arr : np.array, **kwargs):
        self.data = np.ndarray(n_elements, **kwargs)
        self.conv_arr = conv_arr
        self.padding_value = padding_value
        self.reset()

    def reset(self):
        self.data.fill(self.padding_value)

    def __len__(self):
        return len(self.data)

    def update(self, value = None):
        # prev_x = x is passing a value by reference
        # prev_x[...] = x means passing by value
        update_value = self.padding_value if (value is None) else value
        started = True
        for x in np.nditer(self.data, op_flags = ['readwrite']):
            if started: started = False; prev_x = x; continue
            prev_x[...] = x
            prev_x = x
        x[...] = update_value

    def setValue(self, ind : int, value : int):
        self.data[ind] = value

    def convolve(self):
        return np.dot(self.data, self.conv_arr)

def convolveRemainingPixels(update_queues : list, conv_queues : list, channels : int, update_lag : int):
    for chn_ind in range(channels):
        for _ in range(update_lag + 1):
            prev_px = update_queues[chn_ind].get()
            update_val = conv_queues[chn_ind].convolve()
            prev_px[...] = update_val
            conv_queues[chn_ind].update()
        conv_queues[chn_ind].reset()

def verticalConvolution(output_img : np.array, update_lag : int, conv_queues : list, update_queues : list):
    i, j, k = 0, 0, 0
    _, height, width, _, _ = getChannels(output_img)
    for px in np.nditer(output_img, order = 'F', op_flags = ['readwrite']):
        conv_queues[0].update(px)
        update_queues[0].put(px)
        i, j, _ = iterateImageFortran(i, j, k, height, width)
        if i > update_lag:
            prev_px = update_queues[0].get()
            prev_px[...] = conv_queues[0].convolve()
        if (i == 0) and (k == 0):
            convolveRemainingPixels(update_queues, conv_queues, 1, update_lag)
    return output_img

def horizontalConvolution(output_img : np.array, update_lag : int, conv_queues : list, update_queues : list):
    i, j, k = 0, 0, 0
    _, _, width, channels, _ = getChannels(output_img)
    for px in np.nditer(output_img, order = 'C', op_flags = ['readwrite']):
        conv_queues[k].update(px)
        update_queues[k].put(px)
        i, j, k = iterateImage(i, j, k, channels, width)
        if j > update_lag:
            prev_px = update_queues[k].get()
            prev_px[...] = conv_queues[k].convolve()
        if (j == 0) and (k == 0):
            convolveRemainingPixels(update_queues, conv_queues, channels, update_lag)
    return output_img

def getNrChannelsConv(img : np.array, row_or_col : bool):
    if not(row_or_col):
        return 1
    if len(img.shape) == 2:
        return 1
    else:
        return img.shape[2]

def oneDimConvolution(img : np.array, conv_arr : np.array, row_or_col : bool = True, padding_value : int = 255):
    if img.dtype != np.float32: img = np.float32(img) # Will return copy when input image is not float 32
    channels = getNrChannelsConv(img, row_or_col)
    kernel_size = len(conv_arr)
    conv_queues = [fixedSizeQueue(kernel_size, padding_value, conv_arr, dtype = np.float32) for _ in range(channels)]
    update_queues = [SimpleQueue() for _ in range(channels)]
    update_lag = kernel_size//2
    if row_or_col:
        return horizontalConvolution(img, update_lag, conv_queues, update_queues)
    else:
        return verticalConvolution(img, update_lag, conv_queues, update_queues)